############################################
        exp13
############################################
[to-do]:
    1. 增加异常：ADEF, ALE, BRK和INE
    2. 增加rdcntvl.w, rdcntvh.w, rdcntid

[info]:
    1. rdcntv的计时器timecnt在mycpu_top中
    2. ADEF对应的需要WB向CSR传入wb_vaddr

2023.11.2
[info]
    1. ref_exp13仅供参考
    2. exp12存在遗留问题：当mem和wb级位ertn指令时，不应当发出访存请求，
    尤其是读请求
    3. 中断（has_int）到来时会标记在ID级。但是！请务必注意要标记在valid有效的指令上！
    4. 请在最外层的readme.md中简要介绍关键设计，这将大大减小后续实验熟悉代码的难度 :)

2023.11.3
[info]
    1.实现了例外和中断（还不知道是否有bug）
    2.增加了读计数器指令（比较简单，应该不会出bug）
    3.上板通过了

############################################
        exp14 & exp15 & exp16
############################################
2023.11.11
[info]
    1.修改了myCPU的目录结构：
        myCPU
        ├── arith
        │   ├── alu.v
        │   ├── divider.v
        │   └── multiplier.v
        ├── csr
        │   └── csr.v
        ├── dhd
        │   └── data_harzard_detector.v
        ├── macro.vh
        ├── mmu
        │   ├── AXI_convert.v
        │   └── tlb.v
        ├── mycpu_top.v
        ├── pipeline
        │   ├── EX.v
        │   ├── ID.v
        │   ├── IF.v
        │   ├── MEM.v
        │   └── WB.v
        ├── readme
        ├── regfile
        │   └── regfile.v
        └── tools.v
    2. AXI_convert：输入为SRAM信号，输出为AXI信号，最后在myCPU的顶层输出AXI信号，myCPU内例化AXI_convert.
    3. exp14以一种及其丑陋的形式（似乎）跑过了，上板试了好几组随机种子暂时没问题，不保证后续不出错）
    4. 例外优先级没写
2023.11.12
[info]
    1. 修改了preIF和IF的逻辑，访存还没看，阻塞也没改（
    2. 之前的preIF_invalid_req实际上是没有用的，因为IF_allow_in后才发出请求
    3. 进行了修改保证br_taken只有一拍（和wb_ex和ertn_reflush都只有一拍保持一致，设计是按只有一拍的逻辑设计的，不知道会不会出问题）
    4. 对adef的处理进行了修改，指令存在adef时valid不拉低，在有异常时禁止访存、写寄存器
2023.11.13
[info]
    1. 添加了写某些csr寄存器时的阻塞
    2. 和讲义保持一致，流水线在当前流水级无效时允许进入（之前不允许，不过应该没什么差）
    3. 修改了一丢丢访存的逻辑
2023.11.18
[info]
    1. 添加了AXI_convert
    2. 对于data_addr_ok信号，可能描述的不是很准确，主要是讲义上的描述比较含糊，要是大家有清晰的理解可以改一改
    3. 读响应通道的逻辑可能写的有点太复杂了，但是可以支持取指和取数据同时等待数据返回
    4. ！！！在处理跳转到的pc会引发adef异常时，由于跳转的设计会导致br_pc会抢占跳转前pc的读请求发送的araddr，所以这里仍然按照正常指令的方式先等待取指。
